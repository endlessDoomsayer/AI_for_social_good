1. Voglio vedere se riesco a fare tutto solo con pannelli solari e batterie. Si, quanto mi costa? (dati 2024)
2. Con quello che viene fuori il costo mi chiedo: quanto andrei avanti pagando l'enel e non usando i pannelli con quei soldi? (dati 2024)
3. Se il punto 1 non conviene, cioè esempio ottengo 50 anni dal punto 2,
cerco di minimizzare la mia spesa in questi 50 anni facendo il mix tra energia solare e energia importata dall'esterno (dati 2024)
4. Se il punto 1 conviene o il punto 3 mi dice che c'è un buon mix, per avere questo vantaggio faccio ogni giorno lo scheduling per il futuro per non consumare energia (dati giorno per giorno)
I punti 1,2,3 ci fanno capire la strategia migliore. Se è la 1 o la 3 dobbiamo fare un CSP per capire lo scheduling delle macchine giorno per giorno.


WAYS TO SOLVE THE PROBLEMS:
- glpk (1 and 3) =  a software package designed to solve large-scale linear programming (LP), mixed integer programming (MIP), and related problems
- 3 local search = solve initially with glpk (or with something that you know is right), and then try to do small changes on number of panels and batteries (almost all decreasing, something increasing)
- SCIP (4_1 lin prog) = a method used to create a solver instance for solving mixed integer programming (MIP) problems using the SCIP solver. Essentially same as glpk
- CpSolver (4_1 sat) = un po' come gli altri, ma in teoria è più veloce
- enhanced (always uses CpSolver)
   - improved_backtracking = most constrained variable, backjumping, no good learning, least constraining value, node consistency, constraint propagation
   - constraint propagation = node consistency, constraint propagation 
   - simulated annealing = start from a random solution, see neighbors, choose a random one and change solution only if it is a better one (this also depends on the temperature)
   - local beam = with k solutions at random pick all their neighbors and keep the best k among them, and continue
   - genetic algorithm = given a population of solutions, keep the best 20% and create new solutions
   - min conflicts = starting from random, get one of the variables that has conflicts and make it have a value to reduce the conflicts
   - find_min_original = 4_1 sat
   - stochastic hill climbing with random restart = accepts a neighbor if it's better, of if it's worse than only with a certain probability
   - tabu search = it has restarts, occasionally it makes some random moves, gets the neighbor with the least conflicts, 